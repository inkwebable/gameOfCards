<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Deck/Deck.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Deck/Deck.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Card from '../Card/Card';

/**
 * Generate a deck
 * @class
 */
class Deck {

    /**
     *
     * @param id {string}
     * @param name {string}
     * @param elementId {string}
     * @param {object} [options] - options
     * @param  {string} [options.numberOfEachCard=1] - number of each card
     * @param  {object} [options.cardSuits={ 'hearts': 'red', 'clubs': 'black', 'diamonds': 'red', 'spades': 'black' }] - property name will be combined with cardValue property name to generate the card front image path &amp; value will be set to prop suit  e.g ahearts, 2hearts.jpg
     * @param  {object} [options.cardValues={ A: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, J: 11, Q: 12, K: 13 }] - property name will be combined with suit property name to generate the card front image path &amp; value will be set to prop value e.g ahearts, 2hearts.jpg
     * @param  {array} [options.imageNames=[]] - create cards using just card names - should match the name of the images
     * @param  {string} [options.imagePath=images/game-of-cards/default-cards] - where to for the cards
     * @param  {string} [options.backOfCardSrc=back.png] - name of the imaae to use for the back of the card
     * @param  {string} [options.frontOfCardSrc=front.png] - name of the imaae to use for the front of the card
     * @param  {string} [options.cardSectionClass=card-container] - class to use for the card container
     * @param  {string} [options.customCardContainerClass=''] - extra class to use for the card container
     * @param  {string} [options.imageExt=jpg] - extension of the card images to use
     * @param  {boolean} [options.useSuits=true] - define whether to use suits from the cardSuits property
     * @param  {boolean} [options.addValues=true] - define whether to set the card values from the cardValues property
     */
    constructor(id, name = 'standard playing cards', elementId = 'js-deck', options) {
        const defaultOptions = {
            numberOfEachCard: 1,
            cardSuits: { 'hearts': 'red', 'clubs': 'black', 'diamonds': 'red', 'spades': 'black' },
            cardValues: { A: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, J: 11, Q: 12, K: 13 },
            imageNames: [],
            imagePath: 'images/game-of-cards/default-cards',
            backOfCardSrc: 'back.png',
            frontOfCardSrc: 'front.png',
            cardSectionClass: 'card-container',
            customCardContainerClass: '',
            imageExt: 'jpg',
            useSuits: true,
            addValues: true,
        };

        const combinedOptions = Object.assign({}, defaultOptions, options);

        Object.defineProperties(this, {
            '_id': {
                value: id,
                writable: false,
            },
        });
        Object.defineProperties(this, {
            'name': {
                value: name,
                writable: false,
            },
        });

        Object.defineProperties(this, {
            'elementId': {
                value: elementId,
                writable: false,
            },
        });

        this._ids = combinedOptions._ids || [];
        this._DOMCards = combinedOptions._DOMCards || [];
        this._DOMDeck = combinedOptions._DOMDeck || [];
        this.numberOfEachCard = combinedOptions.numberOfEachCard || 1;
        this.cardSuits = combinedOptions.cardSuits;
        this.imageNames = combinedOptions.imageNames;
        this.cardValues = combinedOptions.cardValues;
        this.imagePath = combinedOptions.imagePath;
        this.cardSectionClass = combinedOptions.cardSectionClass;
        this.backOfCardSrc = combinedOptions.backOfCardSrc;
        this.frontOfCardSrc = combinedOptions.frontOfCardSrc;
        this.imageExt = combinedOptions.imageExt;
        this.cards = combinedOptions.cards || [];
        this.customCardContainerClass = combinedOptions.customCardContainerClass;
        this.useSuits = combinedOptions.useSuits;
        this.addValues = combinedOptions.addValues;
        this.areas = combinedOptions.areas;

        this.createDeckObj();
    }


    /**
     * Make random number for card id
     *
     * @param ids
     * @returns {*}
     */
    newNumber(ids) {

        // get random num
        let randId = `_${Math.floor(Math.random() * 10000000)}`;

        // loop check ids array doesn't already have randId
        if (ids.indexOf(randId) === -1) {
            // push it in or get another id
            ids.push(randId);
            return randId;
        } else {
            return this.newNumber(ids)
        }
    }

    /**
     * Make the deck object - need a way to make pairs when the image
     * passed in is to be used more than once, numberOfCards or number of pairs?
     *
     */
    createDeckObj() {
        if (this.imageNames.length > 0) {
            this.imageNames.forEach(name => {
                let count = 0;

                while (count &lt; this.numberOfEachCard) {
                    let randId = this.newNumber(this._ids);

                    let card = new Card({
                        name,
                        value: this.addValues ? this.cardValues[name] : 0,
                        suit: '',
                        image: `${this.imagePath}/${name}.${this.imageExt}`,
                        imageDefault: `${this.imagePath}/${this.frontOfCardSrc}`,
                        cardColor: this.cardSuits.suit,
                        id: randId.toString()
                    });
                    this.cards.push(card);

                    count++;
                }
            });
        } else if (this.useSuits) {
            for (const suit in this.cardSuits) {
                for (const name in this.cardValues) {

                    let count = 0;

                    while (count &lt; this.numberOfEachCard) {
                        let randId = this.newNumber(this._ids);

                        let card = new Card({
                            name,
                            value: this.addValues ? this.cardValues[name] : 0,
                            suit,
                            image: `${this.imagePath}/${name}${suit}.${this.imageExt}`,
                            imageDefault: `${this.imagePath}/${this.frontOfCardSrc}`,
                            cardColor: this.cardSuits.suit,
                            id: randId.toString()
                        });
                        this.cards.push(card);

                        count++;
                    }

                }
            }
        } else {
            for (const name in this.cardValues) {

                let count = 0;

                while (count &lt; this.numberOfEachCard) {
                    let randId = this.newNumber(this._ids);

                    let card = new Card({
                        name,
                        value: this.addValues ? this.cardValues[name] : 0,
                        suit: '',
                        image: `${this.imagePath}/${name}.${this.imageExt}`,
                        imageDefault: `${this.imagePath}/${this.frontOfCardSrc}`,
                        cardColor: this.cardSuits.suit,
                        id: randId.toString()
                    });
                    this.cards.push(card);

                    count++;
                }

            }
        }
    }

    /**
     * make the html markup for appending to DOM
     * how could I allow a user change the mark up?
     */
    makeDomDeck(domCards = this._DOMCards) {

        // push html mark up into array
        for (let i = 0; i &lt; this.cards.length; i++) {
            domCards.push(
              `&lt;section key="${i}" class="${this.cardSectionClass} ${this.customCardContainerClass}" style="transform: translate(0px,0px);">
                &lt;div class="card" id="${this.cards[i]._id}">
                &lt;figure class="back">&lt;img src="${this.imagePath}/${this.backOfCardSrc}" alt="back of card">&lt;/figure>
                &lt;figure class="front">&lt;img src="${this.imagePath}/${this.frontOfCardSrc}" alt="front of card">&lt;/figure>
                &lt;p class="cheat">${this.cards[i].name} ${this.cards[i].suit}&lt;/p>
                &lt;/div>
                &lt;/section>`
            );
        }
    }

    /**
     * Add the deck to a dom element
     *
     * @param elementId
     * @param domString
     */
    addDeckToDOM(elementId = this.elementId, domString = this._DOMCards) {
        document.getElementById(elementId).innerHTML = domString.join('');
    }

    assignCardDomToCardObj(cards = this.cards) {
        let cardNode, realDOM = [];

        for (let card of cards) {
            cardNode = document.getElementById(card._id);
            realDOM.push(cardNode);
            // card.dom = cardNode.parentNode;
            card.setDom(cardNode.parentNode);
        }

        return realDOM;
    }

    /**
     * recursive function for replacing cards upon shuffleDOMOld
     *
     * @param index
     * @param cards
     * @param temp
     * @param len
     * @param deckId
     * @param callback
     */
    // replaceCard(index, cards, temp, len, deckId, callback) {
    //
    //     console.log('core/Deck replaceCard', index, cards, len);
    //     console.log('core/Deck replaceCard', temp[index], cards[index].children[0].id);
    //
    //     temp[index].className = 'card-container shuffle-left';
    //     temp[index].setAttribute('style', 'z-index:' + index);
    //
    //     setTimeout(() => {
    //         document.querySelector('#' + deckId).replaceChild(cards[index], temp[index]);
    //         cards[index].className = 'card-container shuffle-right';
    //         // console.log('card', cards[index]);
    //         //get the card object
    //         let card = this.findCard(cards[index].children[0].id);
    //         // console.log('card', card);
    //
    //         // replace the dom with the new dom
    //         card.dom = cards[index];
    //         // add events to card
    //         card.setUpEvents();
    //         // alert(card);
    //
    //         index++;
    //         if (index &lt; len) {
    //             this.replaceCard(index, cards, temp, len, deckId, callback);
    //         } else {
    //             console.log(callback);
    //             callback();
    //         }
    //
    //     }, 50);
    // }


    /**
     * This shuffles the pure deck card objects
     *
     * @returns {*}
     */
    shuffleCardsObj(array = this.cards) {
        // console.log('core/Deck shuffleDeckObj');
        // do the fisher yates shuffle
        // let array = this.cards;

        let currentIndex = array.length, temporaryValue, randomIndex;

        // While there remain elements to shuffle...
        while (0 !== currentIndex) {

            // Pick a remaining element...
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;

            // And swap it with the current element.
            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
        }

        return array;
    }

    /**
     * Allows finding of card by id (ids are created when deck is created and match id on the dom)
     *
     * @param id
     */
    findCard(id) {
        // @TODO see what happens when card not found
        return this.cards.find(o => o._id === id);
    }

    findCardById(id) {
        return this.cards.find(o => o._id === id);
    }

    /**
     * NOT used
     */
    // flipAllCardsBackToFaceDown() {
    //
    //     // don't have to use DOMCard, can use normal card object as it knows its DOM!?
    //     for (let DOMCard of this._DOMCards) {
    //         let childDiv = DOMCard.children[0];
    //
    //         // card.showBackFace()
    //         let cardObj = this.findCard(childDiv.getAttribute('id'));
    //         cardObj.setDOMClassCard('card');
    //         // childDiv.className = 'card';
    //         cardObj.visible = false;
    //     }
    // }


    /**
     *
     * flip cards back (could be resetPropCards(prop))
     *
     */
    resetFlippedCards(callback) {
        console.log('reset');
        for (let CardObjID in this.flipped) {
            this.flipped[CardObjID].flipCardFaceDown();

        }

        callback();
    }

    /**
     * Used to set up any events - should be on a higher class or removed?
     *
     */
    // setUpEvents() {
    //
    //     this.setUpCardEvents();
    // }

    // think about when we need to setup events on different cards ( e.g in other hands ) differently
    setUpCardEvents() {
        for (let card of this.cards) {
            card.setUpEvents();
        }
    }

    /**
     * Should be allPropCardsTransitioned(prop)??
     *
     * @returns {boolean}
     */
    allFlippedCardsTransitioned() {

        for (let DOMCard in this.flipped) {
            if (this.flipped[DOMCard].transitioning) {
                return false;
            }
        }

        return true;
    }

    /**
     * Check any prop on deck (or game) object for a given number
     *
     * @param prop
     * @param amount
     * @returns {boolean}
     */
    propHasThisManyCards(prop, amount) {

        try {
            if (this.hasOwnProperty(prop)) {
                return Object.keys(this[prop]).length === amount;
            } else {
                // @TODO replace throw with console.error??
                throw 'propertyNoFoundException';
            }
        } catch (e) {
            this.handleMyErrors(e);
        }


    }

    // should be useable from anywhere?
    removeCardFromPropByID(prop, id) {
        // delete this.flipped[cardObj.id];
        return delete this[prop][id];


    }

    //@TODO make own object for handling errors?
    handleMyErrors(e) {
        console.error('error',e);
    }
}

export default Deck;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Card.html">Card</a></li><li><a href="Deck.html">Deck</a></li><li><a href="DefaultPlayer.html">DefaultPlayer</a></li><li><a href="Game.html">Game</a></li><li><a href="Hand.html">Hand</a></li><li><a href="Player.html">Player</a></li><li><a href="PlayerFactory.html">PlayerFactory</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Wed May 20 2020 17:47:31 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
